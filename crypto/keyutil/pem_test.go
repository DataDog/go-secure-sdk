package keyutil

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"io"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

var (
	// Using static PEM encoded key as source, because it's not possible anymore
	// to generate deterministic RSA key pair. (https://github.com/golang/go/issues/38548)
	rsaKeyPEM = `-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCkHFZkI5KYUu13
7qSSf1y+Q2h752bXRwCXpTOV0qxIT7hd+7TrODKJWFpqjZLDRgP+NRLJm2XWBiXI
Afxpo0p7hv2zdISoGs9BtiCpBPfQGm+ktlB5xREsBSxYOobaMTQuRExxaJA3XSwN
gGFlP2u0N5T638Kg6MhWI42EdwLzSq38oH0UFHA02oHgBQT8uHIQGaDdWIcjpivE
E6Gypje/n6WHTtNd7EbocypnJaOl7Opx/iR5gDRhT+4YzGH1UFllIBIj+vDgjr2p
xaEA5PGR5e2GsGrtTmr1q9ugFfnF8u634FhEzGzZkWdWfNFHhn42FDgAjJcrTdGw
nodUwM+5AgMBAAECggEAXh+ynPSaG6tUb7j7wtoxgx5+SrJJlacve8pQb9nI3iB7
CcxX06EDuyplkT9psX3yxFYEVIVAPyR/fttEvgHdskOWNtrZSuE1hebDjK1AxKak
6b93IKAaXTkKWgAXYAVgfDjH7zOdo2NY5NWBBuT9DPvkAo9bvZZFcMIrZJItqwN6
ymd41fAcugOdtZFdQ34srne86n2JEaM1NodNhX6qrWIQeUGRyVzc68hqpadCBtrH
sjnFjs7XBlQqOVa9LlWBsHoShXIxHlLV7blhgT0G5la//ObN1Q7QOM7oNohNJQjH
aun14zeCf/REAXmP3H+1RWwuIbsW6Ov5+gpKuK+iQQKBgQDUXVJLhNDafO/EVFZ0
Ds8iIfr/0w1ykNU0ikrl0hCidzbn/SruB58thkyaAzJB0g7AAFH7AugOHbTm+06q
nm2ymV0TTBv3xcrcKW3loN+cpRJ+dHXrSvjswyPUADEJ3nnghlSolF5CccxPQ6hq
taFbwOYxkliKreRYzkzo0IwB3QKBgQDF1Mt1+9jbXRZboI5fiEy/PVay5XHEnyfE
15IOsJTRtPdl4IpOzQ+7owGpKs9Jph8tRTrHd5l/xpgb6xzZ4DmVPPT3KgDDirS0
dxyzwas2OhM4c68bKfGjvY6WnKYeGUlnoi9a7dNxRHHJOKHGSW6rztNkPc/Ye8H9
yaKUVajdjQKBgQC6C9PYE1CByWio4JYo8PxoU8q4quaiEt6mO+2n7+Pg4X45uaMN
i6HZWUnst5Yk8ek4Lk+kD4TLMR1WKp5dfZRvHkrbaBcsd5zkSmtb/BdK/Zb5MABK
lZEEo2TVCyHrGnw9xpGOawU1QssSOhzm956YaqOAlEx7miJt5racVHAEBQKBgDW/
G0vBkWf/gUyBcUy5DgjC1GQj++WsS7Sp0G+XP8c9gB04hLrl8UlL/u6Dx+89Z6j3
7wE0GArj3H1xQdRbm6lU90STL8PwUinZVn3rtuUzn/ctTrx1h8WxgSSgCG2S9yNl
p7HvfQt/yd4eOa1SU/Pva/UG6gnpjYmyly3vm8IdAoGAaINAnpkj7h5uwy/gLsbH
xaR3dQJ+957xphpjxHBb22mav2V5Ei+MuXIRWxgIrIO25SsdI0KfIoBvziEGdCK8
KbB04TjSYqDic3Kjks2mXBwLj/Z5/gtw1JZWeGfDUeIBihGGjCcNvpF0nWc7rAz8
v3EkmK5exXDRb//5YIOEN4M=
-----END PRIVATE KEY-----`

	rsaPublicKeyPEM = "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApBxWZCOSmFLtd+6kkn9c\nvkNoe+dm10cAl6UzldKsSE+4Xfu06zgyiVhaao2Sw0YD/jUSyZtl1gYlyAH8aaNK\ne4b9s3SEqBrPQbYgqQT30BpvpLZQecURLAUsWDqG2jE0LkRMcWiQN10sDYBhZT9r\ntDeU+t/CoOjIViONhHcC80qt/KB9FBRwNNqB4AUE/LhyEBmg3ViHI6YrxBOhsqY3\nv5+lh07TXexG6HMqZyWjpezqcf4keYA0YU/uGMxh9VBZZSASI/rw4I69qcWhAOTx\nkeXthrBq7U5q9avboBX5xfLut+BYRMxs2ZFnVnzRR4Z+NhQ4AIyXK03RsJ6HVMDP\nuQIDAQAB\n-----END PUBLIC KEY-----\n"

	rsaKeyCabinPEM = "-----BEGIN ENCRYPTED CABIN PRIVATE KEY-----\neyJrZGYiOnsibmFtZSI6InNjcnlwdCIsInZlcnNpb24iOjEsInNhbHQiOiJ3WUtH\nOUtKR0RlQnE4MkZibEgwbzNRPT0ifSwiY2lwaGVyIjp7Im5hbWUiOiJkYXRhZG9n\nL2QyIn0sImNpcGhlcnRleHQiOiIwbjVMVXV2aEZGaG5kb1cvR2J6OGRqenAzWjdX\nN0h5UXNyMWJoOUFmRkoraGxLcXJYWnVTMFI2RDB6NDZxeXRBVGVITjY4T1ZtU1d1\nTUp2b1E3MUhCUytVNWluWGhIeDllMEI1aGkzY1BZWVBDK2VCT0o0TkwyS3RvdFh3\ncUg1RlAwRm9UckNNcDNtdG1vZlJOQ25KdHhCZzhVa3RtcTByc2k1ZDlxendsN2RP\nZmlmb3p0M0Y1MHRScWMrQXowaDJiNW9xRTZQcDBzZUQ3bUQ1T3A1M0NVQlQzUDEr\nWWJNTlRsZDhJQjB2M0Y4d0JNSkM1aTlzQno4OUVIaTFzUU50NWFEY20yeHMwMUIr\nb0syaTNkOVFyOXhSTmozUUExeWgxbzhJSzdNY2VHcm4vRnhwSWJ1d2dFb1VQa2Fu\nUms2RGhrYjhRQ3piajR4WTRIYUlkajFRMWgyYnk3UXVKeGV4YTN2RjBLalhzeFR2\nN1lTZStUV0NldGdVQUNXK2JhZlVXQ2V0dHhBK3lMRU9YdzFlZ016ZU9XTXJ0QVNi\nUkZNNzhRZWZENmlKYnBZYlRUOHBIcFdPckVYK2tETVZmUk5uRzM4VzMrNHlJUkRk\nK2MwV2dZQVdxL2REM1prU2FMQktsSVpUU1ZDSDlYVTR4eUlISXJGeTZKdTBaNVE1\nYkRhVWswQWtVR1hxdi9NN2VxckZ1U2xTbmFNY3lZQ3cyMUFmczB1ZVR5Mm52MldM\nOWptb2FETVQ5SFZxeU93UXd2OElpSnFub2krTUNmbHhmbHc2MDNrNFNORWpKVUxn\nMkFTOVpmU21BaG1Ld3A1T1pmMlNtSnQ0THMyZ0NidEQyVTdBTFJ0SndkNjI4dnY1\nQUNOZzV1dE1RN0ZKdGpLREFnNFRkYmVuMkdjUGttNGhXU2txUXRLbDBVdHY0d29s\nOU03cjdmZjE3Q2FNc0FSRytHamxXem5lN1R0cVViVlRZWVl6RzVZVThxbVRJZm1k\nWlU2L1ArK2djQnJrRU5Pb3orVDBCK0RIRGhQb3BSdlVVYy9qRlB1ZmtDUitwTTJV\nMjl5eWFtYXVwYkwrRjh0cW55N2hjay91SDB0NktmOG4vWnZCa3FhTnVWQ3BxWGFW\nbU1IRE9MTExKV29PQmk4ODRtaHZ6a0RkZzJZZUVORVpBbWpXQXlCR2gyT0VveDNu\ncGdRcDFIQ0VhbEpMaHA2b0tIL0xWTzkyc1R3ZjBnUzkxcnROV2JCK05sbCtBSS9I\nU042V2M1dU1KV1VqNzdhUG9oSjRaZGJ3NkhQMmhaMFl2QXEyMXVvZHpzV2dUTklV\nMXVZUVp5Y2lmMVlkMTBQKzZtdTU1MmJQVlFkMjU1R295djMybklCSlBIZ1ZhVWZU\neG91cG44UTlJaENkZjVLbmJkcm9aY2laQTRqRHBJNWhTckwrdDd4NnFVVTlxcnJt\nem5rY3BNYmJlVGxZdW9YeXJpN2VRdGhFU1FBM1BVZ0EwUk9DWEhIR01uRk9sNWMy\nejFGNmRDUDlPamIzY240RzNNTXFUNlI3NGVIeTlqcHZTcUhlc0VYRVVNLzVjVFhx\nN0lYalYrdnV2NFZmTU81ajIzMmhKTDhNK0RLOUJUY0p2MlVseVI5TWY4QUFJVkYr\nZTNKTmhJaXdRYXY4OWFQUnFiUmxYdUo4MEhHdkVWWlE4NEVMUXJHR05iek1EQXg2\nMXlHc3dNaXBLVnJMa3pBVnFYZThrc0hQTmlYVEgrV1FZQ2x3Nm4raERQcXdKb1F4\neFg4a3QyUFBjeTh4R3lHaW0zQld5QUpwNjZBSXRJVzZSQWtNam1ldm9LY3dQT1lp\nMFN2VnZwUkthdjZFbEZXZzF5MFlNaEVDWExGR2hzNVc4UTczMWZjSThheTdZanp1\ndlFTNG8wUUJJMS9VRGthQzFITk80aE5ZaEMzSFEzdW0vN3pFRmZqN3c1UFFUVnNs\ncldDYU94bUpUbVJ3TWtlT3JZQ3VWOXh2OVR4aUEzSElLVUMrd3FadVppMTlBRVpN\na1dyUDNmWloyU012WHRhVFYvQkpTWXFnMVpQa3ZKNkNOeVFVRWVIZVZFcGhTWGlN\nejBnaEN4MDl2bHZyUktyZ1JSYXpLbi9WdkZqc2xhdkpBZGJyd1J3SnFMOVRQY0hp\naWZQbzMzMC9Fb214Zk9JSmc1OTQvd2RuZkxlcjZFNS82V043VGF3QkUybTV0Umd0\nSzNDd2ZBbC9QUlVMdENZM2MveUQ1N0lDUHI4K1d5cmxEV2t3QWowPSJ9Cg==\n-----END ENCRYPTED CABIN PRIVATE KEY-----\n"

	ecKeyPEM = `-----BEGIN PRIVATE KEY-----
MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCDP4oetAITW/Ow3qtTH
nFCq8hxc2Kwl5ZQyAebKpmIjhg==
-----END PRIVATE KEY-----`

	ed25519KeyPEM = `-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIAYIsKL0xkTkAXDhUN6eDheqODEOGyFZ04jsgFNCFxZf
-----END PRIVATE KEY-----`
)

func TestToDERBytes(t *testing.T) {
	t.Parallel()

	t.Run("nil", func(t *testing.T) {
		t.Parallel()

		b, raw, err := ToDERBytes(nil)
		require.Error(t, err)
		require.Nil(t, raw)
		require.Equal(t, "", b)
	})

	t.Run("invalid key", func(t *testing.T) {
		t.Parallel()

		b, raw, err := ToDERBytes(&struct{}{})
		require.Error(t, err)
		require.Nil(t, raw)
		require.Equal(t, "", b)
	})

	t.Run("rsa", func(t *testing.T) {
		t.Parallel()

		block, _ := pem.Decode([]byte(rsaKeyPEM))
		pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		require.NoError(t, err)
		require.IsType(t, &rsa.PrivateKey{}, pkRaw)
		pk, _ := pkRaw.(*rsa.PrivateKey)

		b, rawPub, err := ToDERBytes(pk.Public())
		require.NoError(t, err)
		require.Equal(t, []byte{0x30, 0x82, 0x1, 0x22, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x3, 0x82, 0x1, 0xf, 0x0, 0x30, 0x82, 0x1, 0xa, 0x2, 0x82, 0x1, 0x1, 0x0, 0xa4, 0x1c, 0x56, 0x64, 0x23, 0x92, 0x98, 0x52, 0xed, 0x77, 0xee, 0xa4, 0x92, 0x7f, 0x5c, 0xbe, 0x43, 0x68, 0x7b, 0xe7, 0x66, 0xd7, 0x47, 0x0, 0x97, 0xa5, 0x33, 0x95, 0xd2, 0xac, 0x48, 0x4f, 0xb8, 0x5d, 0xfb, 0xb4, 0xeb, 0x38, 0x32, 0x89, 0x58, 0x5a, 0x6a, 0x8d, 0x92, 0xc3, 0x46, 0x3, 0xfe, 0x35, 0x12, 0xc9, 0x9b, 0x65, 0xd6, 0x6, 0x25, 0xc8, 0x1, 0xfc, 0x69, 0xa3, 0x4a, 0x7b, 0x86, 0xfd, 0xb3, 0x74, 0x84, 0xa8, 0x1a, 0xcf, 0x41, 0xb6, 0x20, 0xa9, 0x4, 0xf7, 0xd0, 0x1a, 0x6f, 0xa4, 0xb6, 0x50, 0x79, 0xc5, 0x11, 0x2c, 0x5, 0x2c, 0x58, 0x3a, 0x86, 0xda, 0x31, 0x34, 0x2e, 0x44, 0x4c, 0x71, 0x68, 0x90, 0x37, 0x5d, 0x2c, 0xd, 0x80, 0x61, 0x65, 0x3f, 0x6b, 0xb4, 0x37, 0x94, 0xfa, 0xdf, 0xc2, 0xa0, 0xe8, 0xc8, 0x56, 0x23, 0x8d, 0x84, 0x77, 0x2, 0xf3, 0x4a, 0xad, 0xfc, 0xa0, 0x7d, 0x14, 0x14, 0x70, 0x34, 0xda, 0x81, 0xe0, 0x5, 0x4, 0xfc, 0xb8, 0x72, 0x10, 0x19, 0xa0, 0xdd, 0x58, 0x87, 0x23, 0xa6, 0x2b, 0xc4, 0x13, 0xa1, 0xb2, 0xa6, 0x37, 0xbf, 0x9f, 0xa5, 0x87, 0x4e, 0xd3, 0x5d, 0xec, 0x46, 0xe8, 0x73, 0x2a, 0x67, 0x25, 0xa3, 0xa5, 0xec, 0xea, 0x71, 0xfe, 0x24, 0x79, 0x80, 0x34, 0x61, 0x4f, 0xee, 0x18, 0xcc, 0x61, 0xf5, 0x50, 0x59, 0x65, 0x20, 0x12, 0x23, 0xfa, 0xf0, 0xe0, 0x8e, 0xbd, 0xa9, 0xc5, 0xa1, 0x0, 0xe4, 0xf1, 0x91, 0xe5, 0xed, 0x86, 0xb0, 0x6a, 0xed, 0x4e, 0x6a, 0xf5, 0xab, 0xdb, 0xa0, 0x15, 0xf9, 0xc5, 0xf2, 0xee, 0xb7, 0xe0, 0x58, 0x44, 0xcc, 0x6c, 0xd9, 0x91, 0x67, 0x56, 0x7c, 0xd1, 0x47, 0x86, 0x7e, 0x36, 0x14, 0x38, 0x0, 0x8c, 0x97, 0x2b, 0x4d, 0xd1, 0xb0, 0x9e, 0x87, 0x54, 0xc0, 0xcf, 0xb9, 0x2, 0x3, 0x1, 0x0, 0x1}, rawPub)
		require.Equal(t, "PUBLIC KEY", b)

		b, rawPk, err := ToDERBytes(pk)
		require.NoError(t, err)
		require.Equal(t, []byte{0x30, 0x82, 0x4, 0xbd, 0x2, 0x1, 0x0, 0x30, 0xd, 0x6, 0x9, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x1, 0x1, 0x1, 0x5, 0x0, 0x4, 0x82, 0x4, 0xa7, 0x30, 0x82, 0x4, 0xa3, 0x2, 0x1, 0x0, 0x2, 0x82, 0x1, 0x1, 0x0, 0xa4, 0x1c, 0x56, 0x64, 0x23, 0x92, 0x98, 0x52, 0xed, 0x77, 0xee, 0xa4, 0x92, 0x7f, 0x5c, 0xbe, 0x43, 0x68, 0x7b, 0xe7, 0x66, 0xd7, 0x47, 0x0, 0x97, 0xa5, 0x33, 0x95, 0xd2, 0xac, 0x48, 0x4f, 0xb8, 0x5d, 0xfb, 0xb4, 0xeb, 0x38, 0x32, 0x89, 0x58, 0x5a, 0x6a, 0x8d, 0x92, 0xc3, 0x46, 0x3, 0xfe, 0x35, 0x12, 0xc9, 0x9b, 0x65, 0xd6, 0x6, 0x25, 0xc8, 0x1, 0xfc, 0x69, 0xa3, 0x4a, 0x7b, 0x86, 0xfd, 0xb3, 0x74, 0x84, 0xa8, 0x1a, 0xcf, 0x41, 0xb6, 0x20, 0xa9, 0x4, 0xf7, 0xd0, 0x1a, 0x6f, 0xa4, 0xb6, 0x50, 0x79, 0xc5, 0x11, 0x2c, 0x5, 0x2c, 0x58, 0x3a, 0x86, 0xda, 0x31, 0x34, 0x2e, 0x44, 0x4c, 0x71, 0x68, 0x90, 0x37, 0x5d, 0x2c, 0xd, 0x80, 0x61, 0x65, 0x3f, 0x6b, 0xb4, 0x37, 0x94, 0xfa, 0xdf, 0xc2, 0xa0, 0xe8, 0xc8, 0x56, 0x23, 0x8d, 0x84, 0x77, 0x2, 0xf3, 0x4a, 0xad, 0xfc, 0xa0, 0x7d, 0x14, 0x14, 0x70, 0x34, 0xda, 0x81, 0xe0, 0x5, 0x4, 0xfc, 0xb8, 0x72, 0x10, 0x19, 0xa0, 0xdd, 0x58, 0x87, 0x23, 0xa6, 0x2b, 0xc4, 0x13, 0xa1, 0xb2, 0xa6, 0x37, 0xbf, 0x9f, 0xa5, 0x87, 0x4e, 0xd3, 0x5d, 0xec, 0x46, 0xe8, 0x73, 0x2a, 0x67, 0x25, 0xa3, 0xa5, 0xec, 0xea, 0x71, 0xfe, 0x24, 0x79, 0x80, 0x34, 0x61, 0x4f, 0xee, 0x18, 0xcc, 0x61, 0xf5, 0x50, 0x59, 0x65, 0x20, 0x12, 0x23, 0xfa, 0xf0, 0xe0, 0x8e, 0xbd, 0xa9, 0xc5, 0xa1, 0x0, 0xe4, 0xf1, 0x91, 0xe5, 0xed, 0x86, 0xb0, 0x6a, 0xed, 0x4e, 0x6a, 0xf5, 0xab, 0xdb, 0xa0, 0x15, 0xf9, 0xc5, 0xf2, 0xee, 0xb7, 0xe0, 0x58, 0x44, 0xcc, 0x6c, 0xd9, 0x91, 0x67, 0x56, 0x7c, 0xd1, 0x47, 0x86, 0x7e, 0x36, 0x14, 0x38, 0x0, 0x8c, 0x97, 0x2b, 0x4d, 0xd1, 0xb0, 0x9e, 0x87, 0x54, 0xc0, 0xcf, 0xb9, 0x2, 0x3, 0x1, 0x0, 0x1, 0x2, 0x82, 0x1, 0x0, 0x5e, 0x1f, 0xb2, 0x9c, 0xf4, 0x9a, 0x1b, 0xab, 0x54, 0x6f, 0xb8, 0xfb, 0xc2, 0xda, 0x31, 0x83, 0x1e, 0x7e, 0x4a, 0xb2, 0x49, 0x95, 0xa7, 0x2f, 0x7b, 0xca, 0x50, 0x6f, 0xd9, 0xc8, 0xde, 0x20, 0x7b, 0x9, 0xcc, 0x57, 0xd3, 0xa1, 0x3, 0xbb, 0x2a, 0x65, 0x91, 0x3f, 0x69, 0xb1, 0x7d, 0xf2, 0xc4, 0x56, 0x4, 0x54, 0x85, 0x40, 0x3f, 0x24, 0x7f, 0x7e, 0xdb, 0x44, 0xbe, 0x1, 0xdd, 0xb2, 0x43, 0x96, 0x36, 0xda, 0xd9, 0x4a, 0xe1, 0x35, 0x85, 0xe6, 0xc3, 0x8c, 0xad, 0x40, 0xc4, 0xa6, 0xa4, 0xe9, 0xbf, 0x77, 0x20, 0xa0, 0x1a, 0x5d, 0x39, 0xa, 0x5a, 0x0, 0x17, 0x60, 0x5, 0x60, 0x7c, 0x38, 0xc7, 0xef, 0x33, 0x9d, 0xa3, 0x63, 0x58, 0xe4, 0xd5, 0x81, 0x6, 0xe4, 0xfd, 0xc, 0xfb, 0xe4, 0x2, 0x8f, 0x5b, 0xbd, 0x96, 0x45, 0x70, 0xc2, 0x2b, 0x64, 0x92, 0x2d, 0xab, 0x3, 0x7a, 0xca, 0x67, 0x78, 0xd5, 0xf0, 0x1c, 0xba, 0x3, 0x9d, 0xb5, 0x91, 0x5d, 0x43, 0x7e, 0x2c, 0xae, 0x77, 0xbc, 0xea, 0x7d, 0x89, 0x11, 0xa3, 0x35, 0x36, 0x87, 0x4d, 0x85, 0x7e, 0xaa, 0xad, 0x62, 0x10, 0x79, 0x41, 0x91, 0xc9, 0x5c, 0xdc, 0xeb, 0xc8, 0x6a, 0xa5, 0xa7, 0x42, 0x6, 0xda, 0xc7, 0xb2, 0x39, 0xc5, 0x8e, 0xce, 0xd7, 0x6, 0x54, 0x2a, 0x39, 0x56, 0xbd, 0x2e, 0x55, 0x81, 0xb0, 0x7a, 0x12, 0x85, 0x72, 0x31, 0x1e, 0x52, 0xd5, 0xed, 0xb9, 0x61, 0x81, 0x3d, 0x6, 0xe6, 0x56, 0xbf, 0xfc, 0xe6, 0xcd, 0xd5, 0xe, 0xd0, 0x38, 0xce, 0xe8, 0x36, 0x88, 0x4d, 0x25, 0x8, 0xc7, 0x6a, 0xe9, 0xf5, 0xe3, 0x37, 0x82, 0x7f, 0xf4, 0x44, 0x1, 0x79, 0x8f, 0xdc, 0x7f, 0xb5, 0x45, 0x6c, 0x2e, 0x21, 0xbb, 0x16, 0xe8, 0xeb, 0xf9, 0xfa, 0xa, 0x4a, 0xb8, 0xaf, 0xa2, 0x41, 0x2, 0x81, 0x81, 0x0, 0xd4, 0x5d, 0x52, 0x4b, 0x84, 0xd0, 0xda, 0x7c, 0xef, 0xc4, 0x54, 0x56, 0x74, 0xe, 0xcf, 0x22, 0x21, 0xfa, 0xff, 0xd3, 0xd, 0x72, 0x90, 0xd5, 0x34, 0x8a, 0x4a, 0xe5, 0xd2, 0x10, 0xa2, 0x77, 0x36, 0xe7, 0xfd, 0x2a, 0xee, 0x7, 0x9f, 0x2d, 0x86, 0x4c, 0x9a, 0x3, 0x32, 0x41, 0xd2, 0xe, 0xc0, 0x0, 0x51, 0xfb, 0x2, 0xe8, 0xe, 0x1d, 0xb4, 0xe6, 0xfb, 0x4e, 0xaa, 0x9e, 0x6d, 0xb2, 0x99, 0x5d, 0x13, 0x4c, 0x1b, 0xf7, 0xc5, 0xca, 0xdc, 0x29, 0x6d, 0xe5, 0xa0, 0xdf, 0x9c, 0xa5, 0x12, 0x7e, 0x74, 0x75, 0xeb, 0x4a, 0xf8, 0xec, 0xc3, 0x23, 0xd4, 0x0, 0x31, 0x9, 0xde, 0x79, 0xe0, 0x86, 0x54, 0xa8, 0x94, 0x5e, 0x42, 0x71, 0xcc, 0x4f, 0x43, 0xa8, 0x6a, 0xb5, 0xa1, 0x5b, 0xc0, 0xe6, 0x31, 0x92, 0x58, 0x8a, 0xad, 0xe4, 0x58, 0xce, 0x4c, 0xe8, 0xd0, 0x8c, 0x1, 0xdd, 0x2, 0x81, 0x81, 0x0, 0xc5, 0xd4, 0xcb, 0x75, 0xfb, 0xd8, 0xdb, 0x5d, 0x16, 0x5b, 0xa0, 0x8e, 0x5f, 0x88, 0x4c, 0xbf, 0x3d, 0x56, 0xb2, 0xe5, 0x71, 0xc4, 0x9f, 0x27, 0xc4, 0xd7, 0x92, 0xe, 0xb0, 0x94, 0xd1, 0xb4, 0xf7, 0x65, 0xe0, 0x8a, 0x4e, 0xcd, 0xf, 0xbb, 0xa3, 0x1, 0xa9, 0x2a, 0xcf, 0x49, 0xa6, 0x1f, 0x2d, 0x45, 0x3a, 0xc7, 0x77, 0x99, 0x7f, 0xc6, 0x98, 0x1b, 0xeb, 0x1c, 0xd9, 0xe0, 0x39, 0x95, 0x3c, 0xf4, 0xf7, 0x2a, 0x0, 0xc3, 0x8a, 0xb4, 0xb4, 0x77, 0x1c, 0xb3, 0xc1, 0xab, 0x36, 0x3a, 0x13, 0x38, 0x73, 0xaf, 0x1b, 0x29, 0xf1, 0xa3, 0xbd, 0x8e, 0x96, 0x9c, 0xa6, 0x1e, 0x19, 0x49, 0x67, 0xa2, 0x2f, 0x5a, 0xed, 0xd3, 0x71, 0x44, 0x71, 0xc9, 0x38, 0xa1, 0xc6, 0x49, 0x6e, 0xab, 0xce, 0xd3, 0x64, 0x3d, 0xcf, 0xd8, 0x7b, 0xc1, 0xfd, 0xc9, 0xa2, 0x94, 0x55, 0xa8, 0xdd, 0x8d, 0x2, 0x81, 0x81, 0x0, 0xba, 0xb, 0xd3, 0xd8, 0x13, 0x50, 0x81, 0xc9, 0x68, 0xa8, 0xe0, 0x96, 0x28, 0xf0, 0xfc, 0x68, 0x53, 0xca, 0xb8, 0xaa, 0xe6, 0xa2, 0x12, 0xde, 0xa6, 0x3b, 0xed, 0xa7, 0xef, 0xe3, 0xe0, 0xe1, 0x7e, 0x39, 0xb9, 0xa3, 0xd, 0x8b, 0xa1, 0xd9, 0x59, 0x49, 0xec, 0xb7, 0x96, 0x24, 0xf1, 0xe9, 0x38, 0x2e, 0x4f, 0xa4, 0xf, 0x84, 0xcb, 0x31, 0x1d, 0x56, 0x2a, 0x9e, 0x5d, 0x7d, 0x94, 0x6f, 0x1e, 0x4a, 0xdb, 0x68, 0x17, 0x2c, 0x77, 0x9c, 0xe4, 0x4a, 0x6b, 0x5b, 0xfc, 0x17, 0x4a, 0xfd, 0x96, 0xf9, 0x30, 0x0, 0x4a, 0x95, 0x91, 0x4, 0xa3, 0x64, 0xd5, 0xb, 0x21, 0xeb, 0x1a, 0x7c, 0x3d, 0xc6, 0x91, 0x8e, 0x6b, 0x5, 0x35, 0x42, 0xcb, 0x12, 0x3a, 0x1c, 0xe6, 0xf7, 0x9e, 0x98, 0x6a, 0xa3, 0x80, 0x94, 0x4c, 0x7b, 0x9a, 0x22, 0x6d, 0xe6, 0xb6, 0x9c, 0x54, 0x70, 0x4, 0x5, 0x2, 0x81, 0x80, 0x35, 0xbf, 0x1b, 0x4b, 0xc1, 0x91, 0x67, 0xff, 0x81, 0x4c, 0x81, 0x71, 0x4c, 0xb9, 0xe, 0x8, 0xc2, 0xd4, 0x64, 0x23, 0xfb, 0xe5, 0xac, 0x4b, 0xb4, 0xa9, 0xd0, 0x6f, 0x97, 0x3f, 0xc7, 0x3d, 0x80, 0x1d, 0x38, 0x84, 0xba, 0xe5, 0xf1, 0x49, 0x4b, 0xfe, 0xee, 0x83, 0xc7, 0xef, 0x3d, 0x67, 0xa8, 0xf7, 0xef, 0x1, 0x34, 0x18, 0xa, 0xe3, 0xdc, 0x7d, 0x71, 0x41, 0xd4, 0x5b, 0x9b, 0xa9, 0x54, 0xf7, 0x44, 0x93, 0x2f, 0xc3, 0xf0, 0x52, 0x29, 0xd9, 0x56, 0x7d, 0xeb, 0xb6, 0xe5, 0x33, 0x9f, 0xf7, 0x2d, 0x4e, 0xbc, 0x75, 0x87, 0xc5, 0xb1, 0x81, 0x24, 0xa0, 0x8, 0x6d, 0x92, 0xf7, 0x23, 0x65, 0xa7, 0xb1, 0xef, 0x7d, 0xb, 0x7f, 0xc9, 0xde, 0x1e, 0x39, 0xad, 0x52, 0x53, 0xf3, 0xef, 0x6b, 0xf5, 0x6, 0xea, 0x9, 0xe9, 0x8d, 0x89, 0xb2, 0x97, 0x2d, 0xef, 0x9b, 0xc2, 0x1d, 0x2, 0x81, 0x80, 0x68, 0x83, 0x40, 0x9e, 0x99, 0x23, 0xee, 0x1e, 0x6e, 0xc3, 0x2f, 0xe0, 0x2e, 0xc6, 0xc7, 0xc5, 0xa4, 0x77, 0x75, 0x2, 0x7e, 0xf7, 0x9e, 0xf1, 0xa6, 0x1a, 0x63, 0xc4, 0x70, 0x5b, 0xdb, 0x69, 0x9a, 0xbf, 0x65, 0x79, 0x12, 0x2f, 0x8c, 0xb9, 0x72, 0x11, 0x5b, 0x18, 0x8, 0xac, 0x83, 0xb6, 0xe5, 0x2b, 0x1d, 0x23, 0x42, 0x9f, 0x22, 0x80, 0x6f, 0xce, 0x21, 0x6, 0x74, 0x22, 0xbc, 0x29, 0xb0, 0x74, 0xe1, 0x38, 0xd2, 0x62, 0xa0, 0xe2, 0x73, 0x72, 0xa3, 0x92, 0xcd, 0xa6, 0x5c, 0x1c, 0xb, 0x8f, 0xf6, 0x79, 0xfe, 0xb, 0x70, 0xd4, 0x96, 0x56, 0x78, 0x67, 0xc3, 0x51, 0xe2, 0x1, 0x8a, 0x11, 0x86, 0x8c, 0x27, 0xd, 0xbe, 0x91, 0x74, 0x9d, 0x67, 0x3b, 0xac, 0xc, 0xfc, 0xbf, 0x71, 0x24, 0x98, 0xae, 0x5e, 0xc5, 0x70, 0xd1, 0x6f, 0xff, 0xf9, 0x60, 0x83, 0x84, 0x37, 0x83}, rawPk)
		require.Equal(t, "PRIVATE KEY", b)
	})

	t.Run("ec", func(t *testing.T) {
		t.Parallel()

		block, _ := pem.Decode([]byte(ecKeyPEM))
		pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		require.NoError(t, err)
		require.IsType(t, &ecdsa.PrivateKey{}, pkRaw)
		pk, _ := pkRaw.(*ecdsa.PrivateKey)

		b, rawPub, err := ToDERBytes(&pk.PublicKey)
		require.NoError(t, err)
		require.Equal(t, []byte{0x30, 0x59, 0x30, 0x13, 0x6, 0x7, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x2, 0x1, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x3, 0x1, 0x7, 0x3, 0x42, 0x0, 0x4, 0x30, 0x3c, 0x52, 0x9f, 0x1c, 0xad, 0x12, 0x49, 0x5f, 0xea, 0x78, 0xf4, 0xd, 0x32, 0x19, 0x65, 0x76, 0xbb, 0x66, 0xb4, 0xc8, 0xf4, 0x77, 0x5b, 0x16, 0x2e, 0x88, 0xe0, 0x2a, 0x63, 0xa8, 0xc1, 0x6a, 0xca, 0x7e, 0xa, 0x2, 0x6b, 0x7a, 0xde, 0xd1, 0x8b, 0x5c, 0x49, 0x44, 0x72, 0x49, 0x1f, 0xbe, 0x19, 0x9c, 0x3, 0xcf, 0xca, 0x1d, 0xc5, 0x21, 0xa6, 0xb2, 0xf3, 0xbc, 0x70, 0x5d, 0xc0}, rawPub)
		require.Equal(t, "PUBLIC KEY", b)

		b, rawPk, err := ToDERBytes(pk)
		require.NoError(t, err)
		require.Equal(t, []byte{0x30, 0x81, 0x87, 0x2, 0x1, 0x0, 0x30, 0x13, 0x6, 0x7, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x2, 0x1, 0x6, 0x8, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x3, 0x1, 0x7, 0x4, 0x6d, 0x30, 0x6b, 0x2, 0x1, 0x1, 0x4, 0x20, 0xcf, 0xe2, 0x87, 0xad, 0x0, 0x84, 0xd6, 0xfc, 0xec, 0x37, 0xaa, 0xd4, 0xc7, 0x9c, 0x50, 0xaa, 0xf2, 0x1c, 0x5c, 0xd8, 0xac, 0x25, 0xe5, 0x94, 0x32, 0x1, 0xe6, 0xca, 0xa6, 0x62, 0x23, 0x86, 0xa1, 0x44, 0x3, 0x42, 0x0, 0x4, 0x30, 0x3c, 0x52, 0x9f, 0x1c, 0xad, 0x12, 0x49, 0x5f, 0xea, 0x78, 0xf4, 0xd, 0x32, 0x19, 0x65, 0x76, 0xbb, 0x66, 0xb4, 0xc8, 0xf4, 0x77, 0x5b, 0x16, 0x2e, 0x88, 0xe0, 0x2a, 0x63, 0xa8, 0xc1, 0x6a, 0xca, 0x7e, 0xa, 0x2, 0x6b, 0x7a, 0xde, 0xd1, 0x8b, 0x5c, 0x49, 0x44, 0x72, 0x49, 0x1f, 0xbe, 0x19, 0x9c, 0x3, 0xcf, 0xca, 0x1d, 0xc5, 0x21, 0xa6, 0xb2, 0xf3, 0xbc, 0x70, 0x5d, 0xc0}, rawPk)
		require.Equal(t, "PRIVATE KEY", b)
	})

	t.Run("ed25519", func(t *testing.T) {
		t.Parallel()

		block, _ := pem.Decode([]byte(ed25519KeyPEM))
		pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		require.NoError(t, err)
		require.IsType(t, ed25519.PrivateKey{}, pkRaw)
		pk, _ := pkRaw.(ed25519.PrivateKey)

		b, rawPub, err := ToDERBytes(pk.Public())
		require.NoError(t, err)
		require.Equal(t, []byte{0x30, 0x2a, 0x30, 0x5, 0x6, 0x3, 0x2b, 0x65, 0x70, 0x3, 0x21, 0x0, 0xde, 0x67, 0x30, 0x81, 0xfd, 0x83, 0xad, 0x62, 0xd1, 0xde, 0x64, 0x3a, 0x97, 0x67, 0x79, 0xf5, 0xb1, 0x94, 0xea, 0xa5, 0x12, 0xb7, 0x4, 0x2b, 0x96, 0x7d, 0xbe, 0xac, 0xa9, 0x4a, 0xc6, 0x80}, rawPub)
		require.Equal(t, "PUBLIC KEY", b)

		b, rawPk, err := ToDERBytes(pk)
		require.NoError(t, err)
		require.Equal(t, []byte{0x30, 0x2e, 0x2, 0x1, 0x0, 0x30, 0x5, 0x6, 0x3, 0x2b, 0x65, 0x70, 0x4, 0x22, 0x4, 0x20, 0x6, 0x8, 0xb0, 0xa2, 0xf4, 0xc6, 0x44, 0xe4, 0x1, 0x70, 0xe1, 0x50, 0xde, 0x9e, 0xe, 0x17, 0xaa, 0x38, 0x31, 0xe, 0x1b, 0x21, 0x59, 0xd3, 0x88, 0xec, 0x80, 0x53, 0x42, 0x17, 0x16, 0x5f}, rawPk)
		require.Equal(t, "PRIVATE KEY", b)
	})
}

func TestToPEM(t *testing.T) {
	t.Parallel()

	t.Run("rsa", func(t *testing.T) {
		t.Parallel()

		block, _ := pem.Decode([]byte(rsaKeyPEM))
		pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		require.NoError(t, err)
		require.IsType(t, &rsa.PrivateKey{}, pkRaw)
		pk, _ := pkRaw.(*rsa.PrivateKey)

		var out bytes.Buffer
		err = ToPEM(&out, pk.Public())
		require.NoError(t, err)
		require.Equal(t, "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApBxWZCOSmFLtd+6kkn9c\nvkNoe+dm10cAl6UzldKsSE+4Xfu06zgyiVhaao2Sw0YD/jUSyZtl1gYlyAH8aaNK\ne4b9s3SEqBrPQbYgqQT30BpvpLZQecURLAUsWDqG2jE0LkRMcWiQN10sDYBhZT9r\ntDeU+t/CoOjIViONhHcC80qt/KB9FBRwNNqB4AUE/LhyEBmg3ViHI6YrxBOhsqY3\nv5+lh07TXexG6HMqZyWjpezqcf4keYA0YU/uGMxh9VBZZSASI/rw4I69qcWhAOTx\nkeXthrBq7U5q9avboBX5xfLut+BYRMxs2ZFnVnzRR4Z+NhQ4AIyXK03RsJ6HVMDP\nuQIDAQAB\n-----END PUBLIC KEY-----\n", out.String())
	})

	t.Run("ec", func(t *testing.T) {
		t.Parallel()

		block, _ := pem.Decode([]byte(ecKeyPEM))
		pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		require.NoError(t, err)
		require.IsType(t, &ecdsa.PrivateKey{}, pkRaw)
		pk, _ := pkRaw.(*ecdsa.PrivateKey)

		var out bytes.Buffer
		err = ToPEM(&out, pk.Public())
		require.NoError(t, err)
		require.Equal(t, "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEMDxSnxytEklf6nj0DTIZZXa7ZrTI\n9HdbFi6I4CpjqMFqyn4KAmt63tGLXElEckkfvhmcA8/KHcUhprLzvHBdwA==\n-----END PUBLIC KEY-----\n", out.String())
	})

	t.Run("ed25519", func(t *testing.T) {
		t.Parallel()

		block, _ := pem.Decode([]byte(ed25519KeyPEM))
		pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		require.NoError(t, err)
		require.IsType(t, ed25519.PrivateKey{}, pkRaw)
		pk, _ := pkRaw.(ed25519.PrivateKey)

		var out bytes.Buffer
		err = ToPEM(&out, pk.Public())
		require.NoError(t, err)
		require.Equal(t, "-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEA3mcwgf2DrWLR3mQ6l2d59bGU6qUStwQrln2+rKlKxoA=\n-----END PUBLIC KEY-----\n", out.String())
	})
}

func TestFromPEM(t *testing.T) {
	t.Parallel()

	t.Run("nil reader", func(t *testing.T) {
		t.Parallel()

		_, err := FromPEM(nil)
		require.Error(t, err)
	})

	t.Run("too large content", func(t *testing.T) {
		t.Parallel()

		_, err := FromPEM(io.LimitReader(rand.Reader, maxPEMLength+1))
		require.Error(t, err)
	})

	t.Run("invalid PEM block", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN INVALID-----`)
		out, err := FromPEM(in)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("invalid PEM type", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN INVALID-----`)
		out, err := FromPEM(in)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("invalid PEM content", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN PUBLIC KEY-----`)
		out, err := FromPEM(in)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("invalid PEM block type", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN XXX KEY-----\n\n-----END XXX KEY-----\n`)
		out, err := FromPEM(in)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("private key", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(rsaKeyPEM)
		out, err := FromPEM(in)
		require.NoError(t, err)
		require.IsType(t, &rsa.PrivateKey{}, out)
	})

	t.Run("public key", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(rsaPublicKeyPEM)
		out, err := FromPEM(in)
		require.NoError(t, err)
		require.IsType(t, &rsa.PublicKey{}, out)
	})
}

func TestToCabinPEM(t *testing.T) {
	t.Parallel()

	password := []byte("0123456789012345")
	block, _ := pem.Decode([]byte(rsaKeyPEM))
	require.NotNil(t, block)
	pkRaw, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	require.NoError(t, err)
	require.IsType(t, &rsa.PrivateKey{}, pkRaw)
	pk, _ := pkRaw.(*rsa.PrivateKey)

	t.Run("nil writer", func(t *testing.T) {
		t.Parallel()

		err := ToCabinPEM(nil, pk, password)
		require.Error(t, err)
	})

	t.Run("nil key", func(t *testing.T) {
		t.Parallel()

		var out bytes.Buffer
		err := ToCabinPEM(&out, pk, nil)
		require.Error(t, err)
	})

	t.Run("invalid password", func(t *testing.T) {
		t.Parallel()

		var out bytes.Buffer
		err = ToCabinPEM(&out, pk, []byte("0000000000000000"))
		require.NoError(t, err)

		k, err := FromCabinPEM(&out, password)
		require.Error(t, err)
		require.Nil(t, k)
	})

	t.Run("valid", func(t *testing.T) {
		t.Parallel()

		var out bytes.Buffer
		err = ToCabinPEM(&out, pk, password)
		require.NoError(t, err)

		k, err := FromCabinPEM(&out, password)
		require.NoError(t, err)
		require.Equal(t, pk, k)
	})
}

func TestFromCabinPEM(t *testing.T) {
	t.Parallel()

	password := []byte("0123456789012345")

	t.Run("nil reader", func(t *testing.T) {
		t.Parallel()

		_, err := FromCabinPEM(nil, password)
		require.Error(t, err)
	})

	t.Run("too large content", func(t *testing.T) {
		t.Parallel()

		_, err := FromCabinPEM(io.LimitReader(rand.Reader, maxPEMLength+1), password)
		require.Error(t, err)
	})

	t.Run("invalid PEM block", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN INVALID-----`)
		out, err := FromCabinPEM(in, password)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("invalid PEM content", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN PUBLIC KEY-----`)
		out, err := FromCabinPEM(in, password)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("invalid PEM block type", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(`-----BEGIN XXX KEY-----\n\n-----END XXX KEY-----\n`)
		out, err := FromCabinPEM(in, password)
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("password too short", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(rsaKeyCabinPEM)
		out, err := FromCabinPEM(in, []byte(""))
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("bad password", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(rsaKeyCabinPEM)
		out, err := FromCabinPEM(in, []byte("0000000000000000"))
		require.Error(t, err)
		require.Nil(t, out)
	})

	t.Run("valid", func(t *testing.T) {
		t.Parallel()

		in := strings.NewReader(rsaKeyCabinPEM)
		out, err := FromCabinPEM(in, password)
		require.NoError(t, err)
		require.IsType(t, &rsa.PrivateKey{}, out)
	})
}
